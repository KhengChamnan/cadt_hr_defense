✅ 1. Visibility of system status
The system should always keep users informed about what's going on.

Example: Showing a loading spinner when something is processing.

✅ 2. Match between system and the real world
Use familiar language and concepts for users, not technical terms.

Example: Use “Trash” instead of “Delete Buffer”.

✅ 3. User control and freedom
Provide undo and redo. Let users exit or back out of unwanted actions.

Example: A “Cancel” button in forms or modals.

✅ 4. Consistency and standards
Follow platform conventions; users shouldn't wonder if different words mean the same thing.

Example: Use the same color and icon for the same type of action.

✅ 5. Error prevention
Design to prevent problems before they happen.

Example: Disable the "Submit" button until all required fields are filled.

✅ 6. Recognition rather than recall
Reduce memory load by showing options and actions clearly.

Example: Drop-down menus instead of asking users to type commands.

✅ 7. Flexibility and efficiency of use
Allow both novice and expert users to use the system efficiently.

Example: Keyboard shortcuts for power users.

✅ 8. Aesthetic and minimalist design
Keep interfaces clean. Show only what's necessary.

Example: Avoid too much text or decorative elements.

✅ 9. Help users recognize, diagnose, and recover from errors
Use clear, human-readable error messages, and suggest solutions.

Example: “Invalid email address. Please enter a valid one like name@example.com.”

✅ 10. Help and documentation
Even though the system should be usable without it, offer helpful support when needed.

Example: A searchable help center or contextual tooltips.

