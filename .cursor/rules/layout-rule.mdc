---
description: 
globs: 
alwaysApply: false
---
# Flutter Responsive Design Rules for Cursor Agent

## Core Responsive Architecture Rule

**PRIMARY RULE**: Always implement responsive design using a **top-down approach** where screen-level widgets handle responsive calculations and pass dimensions/flags to child widgets.

## Specific Implementation Guidelines

### 1. Screen-Level Widgets (Pages/Screens)
```dart
// ✅ DO: Use LayoutBuilder + MediaQuery at screen level
Widget build(BuildContext context) {
  return LayoutBuilder(
    builder: (context, constraints) {
      final screenWidth = MediaQuery.of(context).size.width;
      final screenHeight = MediaQuery.of(context).size.height;
      final isTablet = screenWidth > 600;
      final isDesktop = screenWidth > 1024;
      
      // Calculate all dimensions here
      final cardHeight = constraints.maxWidth * (isTablet ? 0.25 : 0.35);
      final spacing = isTablet ? 30.0 : 18.0;
      final fontSize = isTablet ? 16.0 : 14.0;
      
      return Column(
        children: [
          CustomWidget(
            width: constraints.maxWidth,
            height: cardHeight,
            isTablet: isTablet,
            fontSize: fontSize,
          ),
        ],
      );
    },
  );
}
```

### 2. Child Widgets (Components/Cards)
```dart
// ✅ DO: Accept responsive parameters from parent
class CustomWidget extends StatelessWidget {
  final double? width;
  final double? height;
  final bool isTablet;
  final double fontSize;
  
  const CustomWidget({
    Key? key,
    this.width,
    this.height,
    this.isTablet = false,
    this.fontSize = 14.0,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // Use passed parameters, minimal internal calculations
    return Container(
      width: width,
      height: height,
      child: Text(
        'Sample Text',
        style: TextStyle(fontSize: fontSize),
      ),
    );
  }
}
```

### 3. Exception Cases
```dart
// ✅ ONLY use LayoutBuilder in child widgets when:
// - Widget needs complex internal layout calculations
// - Widget is highly reusable across different contexts
// - Widget has intricate positioning requirements

class ComplexLayoutWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        // Only for complex internal positioning
        final availableWidth = constraints.maxWidth;
        final iconSize = availableWidth * 0.1;
        
        return Stack(
          children: [
            Positioned(
              right: availableWidth * 0.05,
              child: Icon(size: iconSize),
            ),
          ],
        );
      },
    );
  }
}
```

## Breakpoint Standards
```dart
// Use these consistent breakpoints across all screens
final isPhone = screenWidth < 600;
final isTablet = screenWidth >= 600 && screenWidth < 1024;
final isDesktop = screenWidth >= 1024;
```

## What NOT to Do
```dart
// ❌ DON'T: Multiple LayoutBuilders in the same widget tree
// ❌ DON'T: MediaQuery calls in every child widget
// ❌ DON'T: Hardcoded dimensions without responsive calculations
// ❌ DON'T: Different breakpoint values across widgets
```

## Implementation Checklist
- [ ] Screen widget uses LayoutBuilder for main responsive logic
- [ ] Child widgets accept dimension/flag parameters
- [ ] Consistent breakpoint values (600px, 1024px)
- [ ] Font sizes, spacing, and dimensions scale appropriately
- [ ] Minimal or no LayoutBuilder usage in child widgets
- [ ] All hardcoded values replaced with calculated responsive values

## Performance Optimization
- Calculate responsive values once at screen level
- Pass calculated values down to children
- Avoid nested LayoutBuilder widgets
- Use MediaQuery sparingly (preferably once per screen)

## Code Review Questions
1. "Does this widget really need its own LayoutBuilder?"
2. "Can these dimensions be calculated at the parent level?"
3. "Are we using consistent breakpoints?"
4. "Is this widget accepting responsive parameters from its parent?"

---

**REMEMBER**: Top-down responsive design = Better performance + Consistent UI + Maintainable code